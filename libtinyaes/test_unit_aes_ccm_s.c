#ifdef WITH_AES_CCM_S

#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include <unity_fixture.h>

#include <aes.h>
#include <aes_ccm_s.h>

TEST_GROUP(aes_ccm_s);

TEST_SETUP(aes_ccm_s)
{
    /* Nothing to do here */
}

TEST_TEAR_DOWN(aes_ccm_s)
{
    /* Nothing to do here */
}

struct frame_ptrs {
    uint8_t* mhr;
    uint8_t* payload;
    uint8_t* mic;
    uint8_t* end;
};

#define BUF_SIZE 512
static uint8_t cmp_buf[BUF_SIZE], work_buf[BUF_SIZE];

/* common for both tests GMK key, nonce and adata */
static const uint8_t gmk_key[] = { 0xab, 0x10, 0x34, 0x11, 0x45, 0x11, 0x1b, 0xc3, 0xc1, 0x2d, 0xe8, 0xff, 0x11, 0x14, 0x22, 0x04 };

/* nonce: (PAN_ID) + (src short_addr) + (PAN_ID) + (src short_addr) + (frame counter) + (Security Level=0x05) */
static const uint8_t nonce[] = { 0x78, 0x1d, 0x00, 0x2a, 0x78, 0x1d, 0x00, 0x2a, 0xa0, 0x12, 0x51, 0x23, 0x05 };

/* adata is: G3-PLC, IEEE 802.15.4 MHR with Auxiliary Security Header as received with the first segment */
static const uint8_t adata[] = { 0x69, 0x88, 0x29, 0x1d, 0x78, 0x0c, 0x01, 0x2a, 0x00, 0x0d, 0x23, 0x51, 0x12, 0xa0, 0x00 };

#if defined(PS_DEBUG) && (PS_DEBUG == 1)
static void print_bytestream(FILE* fout, uint8_t* ptr, uint16_t len, uint8_t fg, uint8_t bg, uint8_t width, uint8_t reset)
{
    static int cntr = 0, ofs = 0;
    uint8_t* endptr = ptr + len;

    if (reset) {
        cntr = 0;
        ofs = 0;
    }

    fg &= 0xf, bg &= 0xf;
    fg = fg > 7 ? 90 + (fg & 7) : 30 + fg;  /* foreground color 0..7 dim, 8..15 bright */
    bg = bg > 7 ? 100 + (bg & 7) : 40 + bg; /* background color 0..7 dim, 8..15 bright */

    fprintf(fout, "\033[%02d;%02dm", fg, bg);
    while (ptr < endptr) {
        if (cntr == 0) {
            fprintf(fout, "\033[90m %05d\033[0m | \033[%02d;%02dm", ofs, fg, bg);
            ofs += width;
        }
        fprintf(fout, "%02X ", *ptr++);
        if (cntr++ > width) {
            cntr = 0;
            fputs("\n", fout);
        }
    }
    fputs("\033[0m", fout);
}

static void dump_frame(struct frame_ptrs* ptr, const char msg[])
{
    fprintf(stderr, "\n%s:\n", msg);
    print_bytestream(stderr, ptr->mhr, ptr->payload - ptr->mhr, 14, 0, 20, 1);
    print_bytestream(stderr, ptr->payload, ptr->mic - ptr->payload, 10, 0, 20, 0);
    print_bytestream(stderr, ptr->mic, ptr->end - ptr->mic, 13, 0, 20, 0);
    fputs("\n", stderr);
}

#else
#define dump_frame(ptr, msg) /* no-op */
#endif

/* store complete IEEE 802.15.4 frame in two buffers 'work-on' and 'compare-with' */
static struct frame_ptrs build_frame(const uint8_t* mhr, uint16_t mhr_len, const uint8_t* payload, uint16_t payload_len, const uint8_t* mic, uint8_t mic_len)
{
    struct frame_ptrs ptr;

    TEST_ASSERT_LESS_THAN_MESSAGE(BUF_SIZE, mhr_len + payload_len + mic_len, "Frame bigger than buffer size");

    /* start with copy buffer to save ptrs */
    ptr.mhr = work_buf;
    memcpy(ptr.mhr, mhr, mhr_len);

    /* store Encrypted payload */
    ptr.payload = ptr.mhr + mhr_len;
    memcpy(ptr.payload, payload, payload_len);

    /* store ENC-MIC-32 tag */
    ptr.mic = ptr.payload + payload_len;
    memcpy(ptr.mic, mic, mic_len);

    ptr.end = ptr.mic + mic_len;

    /* duplicate 'work-on' copy buffer to 'compare-with' buffer */
    memcpy(cmp_buf, work_buf, ptr.end - ptr.mhr);

    return ptr;
}

static void make_test(struct frame_ptrs ptr, uint8_t decr_byte)
{
    unsigned int n;
    struct AES_ctx ctx;
    AES_CCM_S_set_key(&ctx, gmk_key);

    dump_frame(&ptr, "encrypted frame");

    /* ENC-MIC-32 is always 4 bytes wide */
    AES_CCM_S_crypt(&ctx, nonce, ptr.mhr, ptr.payload - ptr.mhr, ptr.payload, ptr.mic - ptr.payload, ptr.mic, 4, aes_ccm_s__decrypt);

    dump_frame(&ptr, "decrypted frame");

    /* payload is now decrypted verify its content */
    for (n = 0; n < (ptr.mic - ptr.payload); n++) {
        TEST_ASSERT(ptr.payload[n] == decr_byte);
    }

    AES_CCM_S_crypt(&ctx, nonce, ptr.mhr, ptr.payload - ptr.mhr, ptr.payload, ptr.mic - ptr.payload, ptr.mic, 4, aes_ccm_s__encrypt);

    dump_frame(&ptr, "previously decrypted frame is now encrypted again");

    TEST_ASSERT_EQUAL_INT(0, memcmp(cmp_buf, work_buf, ptr.end - ptr.mhr));
}

/* test vector of "II.1.1 Short frame ciphering" Rec. ITU.T G.9903 (08/2017) */
static void g3_frame_test_short(void)
{
    /* clang-format off */
    /* encrypted payload after segment reassembly (if decrypted it contain a set of octets value=0x75) */
    uint8_t decr_byte = 0x75;
    const uint8_t cdata[] = {
        0x72, 0x1d, 0x8c, 0xf9, 0xaf, 0x91, 0x9f, 0xb1, 0x34, 0x36, 0x31, 0x50, 0xca, 0x78, 0xac, 0xfb, 0xe7, 0x3c, 0xe5,
        0x20, 0x64, 0xc7, 0x28, 0xb2, 0xe0, 0x38, 0x81, 0x57, 0xd0, 0xf1, 0xa3, 0xc1, 0x9c, 0xd1, 0x4f, 0xdd, 0x0d, 0x46,
        0x5c, 0xf5, 0x0d, 0x92, 0x3b, 0x2a, 0x7f,
    };

    const uint8_t mic[] = { 0xb8, 0x7a, 0xb7, 0xb7 };

    make_test(build_frame(adata, sizeof(adata), cdata, sizeof(cdata), mic, sizeof(mic)), decr_byte);
    /* clang-format on */
}


/* test vector of "II.1.2 Long frame ciphering" Rec. ITU.T G.9903 (08/2017) */
static void g3_frame_test_long(void)
{
    /* clang-format off */
    /* encrypted payload after segment reassembly (if decrypted it contain a set of octets value=0xA2) */
    uint8_t decr_byte = 0xA2;
    const uint8_t cdata[] = {
        0xa5, 0xca, 0x5b, 0x2e, 0x78, 0x46, 0x48, 0x66, 0xe3, 0xe1, 0xe6, 0x87, 0x1d, 0xaf, 0x7b, 0x2c, 0x30, 0xeb, 0x32,
        0xf7, 0xb3, 0x10, 0xff, 0x65, 0x37, 0xef, 0x56, 0x80, 0x07, 0x26, 0x74, 0x16, 0x4b, 0x06, 0x98, 0x0a, 0xda, 0x91,
        0x8b, 0x22, 0xda, 0x45, 0xec, 0xfd, 0xa8, 0x97, 0x7b, 0xab, 0x71, 0x3e, 0x13, 0xf7, 0x62, 0xc4, 0xdc, 0x7a, 0x03,
        0x71, 0xdc, 0x3d, 0xe7, 0x01, 0x59, 0x46, 0x6d, 0x54, 0x04, 0x4d, 0x31, 0xdb, 0x4b, 0x9c, 0xb6, 0x26, 0xd2, 0x24,
        0xcd, 0x26, 0xf1, 0x30, 0x00, 0x9d, 0x42, 0xa1, 0x76, 0xb0, 0xfe, 0x8e, 0x01, 0x08, 0xec, 0xc0, 0x3c, 0x48, 0x85,
        0xa8, 0xa8, 0x6b, 0x21, 0x64, 0xe7, 0x8d, 0xe0, 0xc6, 0x7f, 0x80, 0x1f, 0x9b, 0x35, 0xdc, 0xd8, 0x09, 0xac, 0x5a,
        0x88, 0x06, 0xbf, 0xba, 0x29, 0xc8, 0x82, 0xbc, 0x68, 0xee, 0x42, 0xf2, 0xc2, 0x05, 0xe0, 0xdf, 0x12, 0xfe, 0xa7,
        0xbd, 0x78, 0x69, 0x38, 0xe0, 0xff, 0x5b, 0xe4, 0x64, 0x3a, 0x5d, 0x24, 0x98, 0xb0, 0xe4, 0x7e, 0x9f, 0x76, 0xb2,
        0x6c, 0x98, 0xe7, 0x86, 0x05, 0xbc, 0x7a, 0xd8, 0x5d, 0x6d, 0x27, 0x87, 0x05, 0x59, 0x27, 0xf8, 0xde, 0xfd, 0xd7,
        0x2a, 0x31, 0x7f, 0x7d, 0x0d, 0x79, 0x83, 0xc6, 0x8a, 0xd9, 0x1b, 0x06, 0x51, 0xe6, 0x9d, 0x6d, 0x83, 0xa3, 0x69,
        0x58, 0x38, 0x92, 0x10, 0x80, 0x00, 0x86, 0xd3, 0x93, 0x43, 0x82, 0xee, 0x89, 0x83, 0x79, 0xc3, 0xc6, 0x66, 0xb7,
        0xd2, 0xb9, 0xdd, 0x81, 0x5d, 0xb7, 0xb3, 0xfa, 0x48, 0x05, 0x12, 0x16, 0xa9, 0xb5, 0x6d, 0xfc, 0xb4, 0x2d, 0xac,
        0x6a, 0x0f, 0xe2, 0x74, 0xc2, 0x7b, 0xea, 0x44, 0x3b, 0xb0, 0x2e, 0x57, 0x74, 0x82, 0x91, 0x73, 0xb9, 0xa0, 0x68,
        0x71, 0x16, 0x85, 0xd5, 0x11, 0xf7, 0x50, 0x2e, 0x1e, 0xd7, 0xaa, 0xc8, 0x0b, 0x5f, 0x75, 0x29, 0xdc, 0x91, 0xee,
        0xde, 0xd1, 0xcc, 0x22, 0x3f, 0x25, 0x7d, 0xa1, 0xde, 0x02, 0xc2, 0x94, 0x57, 0xec, 0xf2, 0x6d, 0xb4, 0x5d, 0xb8,
        0x6b, 0x6f, 0x49, 0x5d, 0x7e, 0x4c, 0x54, 0xab, 0x42, 0x41, 0x8c, 0x37, 0xf2, 0xe1, 0xab,
    };

    const uint8_t mic[] = { 0xdd, 0x28, 0xe3, 0x42 };

    make_test(build_frame(adata, sizeof(adata), cdata, sizeof(cdata), mic, sizeof(mic)), decr_byte);
    /* clang-format on */
}

TEST(aes_ccm_s, g3_plc_test_vector__short_frame)
{
    g3_frame_test_short();
}

TEST(aes_ccm_s, g3_plc_test_vector__long_frame)
{
    g3_frame_test_long();
}

TEST_GROUP_RUNNER(aes_ccm_s)
{
    RUN_TEST_CASE(aes_ccm_s, g3_plc_test_vector__short_frame);
    RUN_TEST_CASE(aes_ccm_s, g3_plc_test_vector__long_frame);
}

#endif /* end of WITH_AES_CCM_S */
